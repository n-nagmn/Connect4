<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Connect 4 - Online Edition</title>
<style>
  :root {
    --bg-color: #bbccc3;
    --board-bg: rgba(50, 58, 70, 0.6);
    --cell-bg: #52689e;
    --p1-color-1: #f87171;
    --p1-color-2: #dc2626;
    --p1-shadow: rgba(220, 38, 38, 0.5);
    --p2-color-1: #fde047;
    --p2-color-2: #ca8a04;
    --p2-shadow: rgba(202, 138, 4, 0.5);
    --accent: #22d3ee;
    --text-main: #f8fafc;
    --text-muted: #fafcff;
  }

  body {
    font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    text-align: center;
    background: radial-gradient(circle at top, #c5baa5, var(--bg-color));
    color: var(--text-main);
    margin: 0;
    padding: 20px;
    min-height: 100vh;
    display: flex;
    justify-content: center;
  }

  #game-container {
    display: flex;
    flex-direction: column;
    align-items: center;
    width: 100%;
    max-width: 800px;
  }

  h1 {
    margin: 0 0 20px 0;
    font-size: 2.5em;
    font-weight: 800;
    background: linear-gradient(to right, #ffffff, #ffffff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    text-shadow: 0 4px 15px rgba(0,0,0,0.3);
  }

  #status-container {
    height: 30px;
    margin-bottom: 15px;
  }

  #status {
    font-size: 1.3em;
    font-weight: 600;
    letter-spacing: 1px;
    color: var(--text-main);
    text-shadow: 0 2px 4px rgba(0,0,0,0.5);
  }

  #score {
    display: flex;
    justify-content: space-between;
    width: 100%;
    max-width: 650px;
    margin-bottom: 25px;
    gap: 20px;
  }

  .player-card {
    flex: 1;
    background: var(--board-bg);
    backdrop-filter: blur(10px);
    border: 2px solid rgba(255,255,255,0.05);
    border-radius: 16px;
    padding: 15px;
    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  .player-card.active-1 {
    border-color: var(--p1-color-1);
    box-shadow: 0 0 20px var(--p1-shadow);
    transform: translateY(-5px);
  }

  .player-card.active-2 {
    border-color: var(--p2-color-1);
    box-shadow: 0 0 20px var(--p2-shadow);
    transform: translateY(-5px);
  }

  .player-name {
    font-size: 1.1em;
    font-weight: 600;
    color: var(--text-muted);
    margin-bottom: 5px;
  }

  .player-card.active-1 .player-name { color: var(--p1-color-1); }
  .player-card.active-2 .player-name { color: var(--p2-color-1); }

  .player-score {
    font-size: 2.5em;
    font-weight: 800;
    line-height: 1;
  }

  .items-container {
    display: flex;
    gap: 8px;
    margin-top: 10px;
    min-height: 44px;
  }

  .item-btn {
    padding: 8px 12px;
    font-size: 1.2em;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 8px;
    background: rgba(0,0,0,0.4);
    color: white;
    cursor: pointer;
    transition: all 0.2s;
    box-shadow: 0 2px 5px rgba(0,0,0,0.3);
  }

  .item-btn:hover {
    background: rgba(255,255,255,0.1);
    transform: translateY(-2px);
  }

  .item-btn.selected {
    border-color: var(--accent);
    background: rgba(34, 211, 238, 0.15);
    box-shadow: 0 0 12px rgba(34, 211, 238, 0.4);
    transform: scale(1.1);
  }

  #board {
    display: inline-grid;
    grid-template-columns: repeat(9, 55px);
    grid-template-rows: repeat(7, 55px);
    gap: 10px;
    background: var(--board-bg);
    backdrop-filter: blur(12px);
    padding: 15px;
    border-radius: 20px;
    border: 1px solid rgba(255,255,255,0.1);
    box-shadow: 0 15px 35px rgba(0,0,0,0.5), inset 0 2px 5px rgba(255,255,255,0.05);
  }

  .cell {
    width: 55px;
    height: 55px;
    background: var(--cell-bg);
    border-radius: 50%;
    cursor: pointer;
    box-shadow: inset 0 5px 10px rgba(0,0,0,0.8);
    transition: transform 0.2s;
    position: relative;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 24px;
    font-weight: bold;
    color: rgb(247, 247, 247);
    user-select: none;
  }

  .cell:hover {
    background: #151f32;
  }

  .p1, .p2 {
    color: transparent;
  }

  .p1::before, .p2::before {
    content: '';
    position: absolute;
    top: 5px; left: 5px; right: 5px; bottom: 5px;
    border-radius: 50%;
    box-shadow: inset 0 3px 6px rgba(255,255,255,0.4), 0 4px 8px rgba(0,0,0,0.5);
  }

  .p1::before {
    background: radial-gradient(circle at 35% 35%, var(--p1-color-1), var(--p1-color-2));
    box-shadow: inset 0 3px 6px rgba(255,255,255,0.4), 0 0 15px var(--p1-shadow);
  }

  .p2::before {
    background: radial-gradient(circle at 35% 35%, var(--p2-color-1), var(--p2-color-2));
    box-shadow: inset 0 3px 6px rgba(255,255,255,0.6), 0 0 15px var(--p2-shadow);
  }

  @keyframes winPulse {
    0% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7); border: 2px solid transparent; }
    50% { box-shadow: 0 0 0 12px rgba(34, 197, 94, 0); border: 2px solid #4ade80; }
    100% { box-shadow: 0 0 0 0 rgba(34, 197, 94, 0); border: 2px solid transparent; }
  }

  .highlight::before {
    animation: winPulse 1.5s infinite;
  }

  button.action-btn {
    margin-top: 30px;
    padding: 12px 30px;
    font-size: 1.1em;
    font-weight: bold;
    cursor: pointer;
    border: 1px solid rgba(255,255,255,0.1);
    border-radius: 30px;
    background: rgba(30, 41, 59, 0.8);
    color: var(--text-main);
    backdrop-filter: blur(5px);
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  button.action-btn:hover {
    background: rgba(51, 65, 85, 0.9);
    border-color: rgba(255,255,255,0.3);
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(0,0,0,0.3);
  }
  
  button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }
</style>
</head>
<body>

<div id="game-container">
  <h1>CONNECT 4 ONLINE</h1>
  
  <div id="score">
    <div id="p1-card" class="player-card active-1">
      <div class="player-name">PLAYER 1</div>
      <div class="player-score" id="score1" style="color: var(--p1-color-1);">0</div>
      <div id="p1-items" class="items-container"></div>
    </div>
    
    <div id="p2-card" class="player-card">
      <div class="player-name">PLAYER 2</div>
      <div class="player-score" id="score2" style="color: var(--p2-color-1);">0</div>
      <div id="p2-items" class="items-container"></div>
    </div>
  </div>

  <div id="status-container">
    <div id="status">„Ç≤„Éº„É†„ÇíÈñãÂßã„Åó„Å¶„Åè„Å†„Åï„ÅÑ</div>
  </div>

  <div id="board"></div>
  <button class="action-btn" id="start-btn">Matchmaking</button>
</div>

<script>
  const ROWS = 7;
  const COLS = 9;
  const WIN_TARGET = 3;
  const ITEM_TYPES = ['x2', 'üí£', 'üå™', '‚áî'];
  
  let board = Array.from({ length: ROWS }, () => Array(COLS).fill(null));
  let currentPlayer = 1;
  let scores = { 1: 0, 2: 0 };
  let gameOver = false;
  let questionMarks = new Set();
  let playerItems = { 1: [], 2: [] };
  let activeItemIndex = -1;
  let currentHighlights = [];
  let pieceIdCounter = 1;
  let claimedPieces = new Set();

  let myPlayerId = 'p_' + Date.now() + Math.floor(Math.random() * 10000);
  let sysState = {
      game_id: null,
      my_role: null,
      player_1_id: null,
      player_2_id: null,
      current_turn_id: null,
      status: "init"
  };
  let pollingInterval = null;

  const boardEl = document.getElementById('board');
  const statusEl = document.getElementById('status');
  const score1El = document.getElementById('score1');
  const score2El = document.getElementById('score2');
  const p1Card = document.getElementById('p1-card');
  const p2Card = document.getElementById('p2-card');
  const p1ItemsEl = document.getElementById('p1-items');
  const p2ItemsEl = document.getElementById('p2-items');
  const startBtn = document.getElementById('start-btn');

  function initBoardDOM() {
    boardEl.innerHTML = '';
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cell = document.createElement('div');
        cell.className = 'cell';
        cell.dataset.row = r;
        cell.dataset.col = c;
        cell.addEventListener('click', () => handleColumnClick(c));
        boardEl.appendChild(cell);
      }
    }
  }

  function toggleItem(index) {
    if (gameOver || sysState.status !== 'playing') return;
    let myNum = sysState.my_role === 'player_1' ? 1 : 2;
    if (currentPlayer !== myNum) return;
    
    activeItemIndex = activeItemIndex === index ? -1 : index;
    renderItems();
  }

  async function handleColumnClick(col) {
    if (gameOver || sysState.status !== 'playing') return;
    let myNum = sysState.my_role === 'player_1' ? 1 : 2;
    if (currentPlayer !== myNum) return;
    
    let row = ROWS - 1;
    while (row >= 0 && board[row][col] !== null) {
      row--;
    }
    if (row < 0) return;

    let usedItem = null;
    if (activeItemIndex !== -1 && playerItems[currentPlayer][activeItemIndex]) {
      usedItem = playerItems[currentPlayer].splice(activeItemIndex, 1)[0];
      activeItemIndex = -1;
    }

    let newPiece = { p: currentPlayer, id: pieceIdCounter++ };
    board[row][col] = newPiece;

    if (questionMarks.has(`${row},${col}`)) {
      let randomItem = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
      playerItems[currentPlayer] = [randomItem];
      claimedPieces.add(newPiece.id);
    }

    if (usedItem === 'x2') {
      if (row - 1 >= 0) {
        let extraPiece = { p: currentPlayer, id: pieceIdCounter++ };
        board[row - 1][col] = extraPiece;
        if (questionMarks.has(`${row - 1},${col}`)) {
          let randomItem = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
          playerItems[currentPlayer] = [randomItem];
          claimedPieces.add(extraPiece.id);
        }
      }
    } else if (usedItem === 'üí£') {
      board[row][col] = null; 
      if (row + 1 < ROWS) board[row + 1][col] = null; 
      if (col + 1 < COLS) board[row][col + 1] = null; 
      if (col - 1 >= 0) board[row][col - 1] = null; 
    } else if (usedItem === 'üå™') {
      let allPieces = [];
      for (let r = 0; r < ROWS; r++) {
        for (let c = 0; c < COLS; c++) {
          if (board[r][c] !== null) {
            allPieces.push(board[r][c]);
            board[r][c] = null;
          }
        }
      }
      allPieces.sort(() => Math.random() - 0.5);
      let isRight = Math.random() < 0.5;
      for (let piece of allPieces) {
        let dropCol;
        let attempts = 0;
        do {
          let rand = Math.pow(Math.random(), 1.5);
          let biasedIndex = Math.floor(rand * COLS);
          if (biasedIndex >= COLS) biasedIndex = COLS - 1;
          dropCol = isRight ? (COLS - 1 - biasedIndex) : biasedIndex;
          attempts++;
          if (attempts > 50) dropCol = Math.floor(Math.random() * COLS);
        } while (board[0][dropCol] !== null);
        
        let targetRow = ROWS - 1;
        while (targetRow >= 0 && board[targetRow][dropCol] !== null) {
          targetRow--;
        }
        if (targetRow >= 0) board[targetRow][dropCol] = piece;
      }
    } else if (usedItem === '‚áî') {
      const targets = [[0, 0], [1, 0], [0, 1], [0, -1]];
      targets.forEach(([dr, dc]) => {
        let r = row + dr;
        let c = col + dc;
        if (r >= 0 && r < ROWS && c >= 0 && c < COLS && board[r][c] !== null) {
          if (board[r][c].p === 1) board[r][c].p = 2;
          else if (board[r][c].p === 2) board[r][c].p = 1;
        }
      });
    }

    applyGravity();
    checkQuestionMarks();
    calculateScores();

    if (scores[currentPlayer] >= WIN_TARGET || scores[currentPlayer === 1 ? 2 : 1] >= WIN_TARGET) {
      gameOver = true;
    } else if (isBoardFull()) {
      explodeBottomRows();
      applyGravity();
      checkQuestionMarks();
      calculateScores();
      if (scores[currentPlayer] >= WIN_TARGET || scores[currentPlayer === 1 ? 2 : 1] >= WIN_TARGET) gameOver = true;
    }

    currentPlayer = currentPlayer === 1 ? 2 : 1;
    renderAll();
    await sendStateUpdate();
  }

  function applyGravity() {
    for (let c = 0; c < COLS; c++) {
      let colPieces = [];
      for (let r = ROWS - 1; r >= 0; r--) {
        if (board[r][c] !== null) {
          colPieces.push(board[r][c]);
          board[r][c] = null;
        }
      }
      let r = ROWS - 1;
      for (let piece of colPieces) {
        board[r][c] = piece;
        r--;
      }
    }
  }

  function checkQuestionMarks() {
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        let key = `${r},${c}`;
        if (questionMarks.has(key) && board[r][c] !== null) {
          let piece = board[r][c];
          if (!claimedPieces.has(piece.id)) {
            claimedPieces.add(piece.id);
            let randomItem = ITEM_TYPES[Math.floor(Math.random() * ITEM_TYPES.length)];
            playerItems[piece.p] = [randomItem];
          }
        }
      }
    }
  }

  function explodeBottomRows() {
    for (let c = 0; c < COLS; c++) {
      board[6][c] = board[2][c];
      board[5][c] = board[1][c];
      board[4][c] = board[0][c];
      board[3][c] = null;
      board[2][c] = null;
      board[1][c] = null;
      board[0][c] = null;
    }
  }

  function calculateScores() {
    scores = { 1: 0, 2: 0 };
    currentHighlights = [];
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        if (board[r][c] === null) continue;
        let player = board[r][c].p;
        const directions = [[0, 1], [1, 0], [1, 1], [1, -1]];
        directions.forEach(([dr, dc]) => {
          let prevR = r - dr;
          let prevC = c - dc;
          if (prevR >= 0 && prevR < ROWS && prevC >= 0 && prevC < COLS && board[prevR][prevC] !== null && board[prevR][prevC].p === player) return; 
          let k = 1;
          let lineCoords = [`${r},${c}`];
          while (true) {
            let nextR = r + dr * k;
            let nextC = c + dc * k;
            if (nextR >= 0 && nextR < ROWS && nextC >= 0 && nextC < COLS && board[nextR][nextC] !== null && board[nextR][nextC].p === player) {
              lineCoords.push(`${nextR},${nextC}`);
              k++;
            } else {
              break;
            }
          }
          let lines = Math.floor(k / 4);
          if (lines > 0) {
            scores[player] += lines;
            let highlightCount = lines * 4;
            for (let i = 0; i < highlightCount; i++) currentHighlights.push(lineCoords[i]);
          }
        });
      }
    }
  }

  function isBoardFull() {
    return board[0].every(cell => cell !== null);
  }

  function renderAll() {
    const cells = boardEl.children;
    for (let r = 0; r < ROWS; r++) {
      for (let c = 0; c < COLS; c++) {
        const cellIdx = r * COLS + c;
        const cellEl = cells[cellIdx];
        cellEl.className = 'cell';
        cellEl.textContent = '';
        
        if (board[r][c] !== null) {
          if (board[r][c].p === 1) cellEl.classList.add('p1');
          else if (board[r][c].p === 2) cellEl.classList.add('p2');
        } else if (questionMarks.has(`${r},${c}`)) {
          cellEl.textContent = '?';
        }
      }
    }

    currentHighlights.forEach(coord => {
      const [r, c] = coord.split(',').map(Number);
      cells[r * COLS + c].classList.add('highlight');
    });

    score1El.textContent = scores[1];
    score2El.textContent = scores[2];
    
    if (gameOver) {
      let winner = scores[1] >= WIN_TARGET ? 1 : 2;
      statusEl.textContent = `PLAYER ${winner} WINS!`;
      statusEl.style.color = winner === 1 ? 'var(--p1-color-1)' : 'var(--p2-color-1)';
      p1Card.classList.toggle('active-1', winner === 1);
      p2Card.classList.toggle('active-2', winner === 2);
    } else if (sysState.status === 'playing') {
      let myNum = sysState.my_role === 'player_1' ? 1 : 2;
      if (currentPlayer === myNum) {
        statusEl.textContent = `„ÅÇ„Å™„Åü„ÅÆ„Çø„Éº„É≥„Åß„Åô`;
        statusEl.style.color = "var(--text-main)";
      } else {
        statusEl.textContent = `Áõ∏Êâã„ÅÆ„Çø„Éº„É≥„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...`;
        statusEl.style.color = "var(--text-muted)";
      }
      p1Card.classList.toggle('active-1', currentPlayer === 1);
      p2Card.classList.toggle('active-2', currentPlayer === 2);
    } else if (sysState.status === 'waiting') {
      statusEl.textContent = `ÂØæÊà¶Áõ∏Êâã„ÇíÂæÖ„Å£„Å¶„ÅÑ„Åæ„Åô...`;
      statusEl.style.color = "var(--text-main)";
    }
    
    renderItems();
  }

  function renderItems() {
    p1ItemsEl.innerHTML = '';
    playerItems[1].forEach((item, idx) => {
      const btn = document.createElement('button');
      btn.className = 'item-btn';
      btn.textContent = item;
      let myNum = sysState.my_role === 'player_1' ? 1 : 2;
      if (currentPlayer === 1 && myNum === 1 && activeItemIndex === idx) btn.classList.add('selected');
      btn.onclick = () => { if (myNum === 1) toggleItem(idx); };
      p1ItemsEl.appendChild(btn);
    });

    p2ItemsEl.innerHTML = '';
    playerItems[2].forEach((item, idx) => {
      const btn = document.createElement('button');
      btn.className = 'item-btn';
      btn.textContent = item;
      let myNum = sysState.my_role === 'player_1' ? 1 : 2;
      if (currentPlayer === 2 && myNum === 2 && activeItemIndex === idx) btn.classList.add('selected');
      btn.onclick = () => { if (myNum === 2) toggleItem(idx); };
      p2ItemsEl.appendChild(btn);
    });
  }

  async function sendStateUpdate() {
    let state = {
      board: board,
      scores: scores,
      questionMarks: Array.from(questionMarks),
      playerItems: playerItems,
      claimedPieces: Array.from(claimedPieces),
      pieceIdCounter: pieceIdCounter
    };
    
    let next_turn_id = (currentPlayer === 1) ? sysState.player_1_id : sysState.player_2_id;
    let winner_id = null;
    let newStatus = 'playing';
    
    if (gameOver) {
      newStatus = 'finished';
      winner_id = (scores[1] >= WIN_TARGET) ? sysState.player_1_id : sysState.player_2_id;
    }
    
    await fetch('api_update_state.php', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        game_id: sysState.game_id,
        game_state: JSON.stringify(state),
        current_turn_id: next_turn_id,
        status: newStatus,
        winner_id: winner_id
      })
    });
    fetchState();
  }

  startBtn.addEventListener('click', async () => {
    try {
      const response = await fetch('api_find_game.php', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ my_player_id: myPlayerId })
      });
      const data = await response.json();
      if (data.error) throw new Error(data.error);

      sysState.game_id = data.game_id;
      sysState.my_role = data.role;
      startBtn.disabled = true;
      startBtn.textContent = sysState.my_role === 'player_1' ? "P1: Waiting..." : "P2: Joined";
      startPolling();
    } catch (err) {
      console.error(err);
    }
  });

  function startPolling() {
    if (pollingInterval) clearInterval(pollingInterval);
    fetchState();
    pollingInterval = setInterval(fetchState, 1500);
  }

  async function fetchState() {
    if (!sysState.game_id) return;
    try {
      const response = await fetch(`api_get_state.php?game_id=${sysState.game_id}`);
      const data = await response.json();
      if (data.error) throw new Error(data.error);

      sysState.status = data.status;
      sysState.current_turn_id = data.current_turn_id;
      sysState.winner_id = data.winner_id;
      sysState.player_1_id = data.player_1_id;
      sysState.player_2_id = data.player_2_id;

      if (data.game_state) {
        let stateObj = JSON.parse(data.game_state);
        board = stateObj.board;
        scores = stateObj.scores;
        questionMarks = new Set(stateObj.questionMarks);
        playerItems = stateObj.playerItems;
        claimedPieces = new Set(stateObj.claimedPieces);
        pieceIdCounter = stateObj.pieceIdCounter;
      }

      currentPlayer = (sysState.current_turn_id === sysState.player_1_id) ? 1 : 2;
      if (sysState.status === 'finished') gameOver = true;
      
      calculateScores();
      renderAll();

      if (sysState.status === 'finished') {
        clearInterval(pollingInterval);
      }
    } catch (err) {
      console.error(err);
    }
  }

  initBoardDOM();
</script>
</body>
</html>